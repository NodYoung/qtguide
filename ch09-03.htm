<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>ch09-03</title>
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="thumbnailviewer.css" type="text/css">
    <script src="thumbnailviewer.js" type="text/javascript">

/***********************************************
* Image Thumbnail Viewer Script- © Dynamic Drive (www.dynamicdrive.com)
* This notice must stay intact for legal use.
* Visit http://www.dynamicdrive.com/ for full source code
***********************************************/

</script> </head>
  <body>
    <div class="os1">9.3 关联容器：QMap、QMultiMap和QSet </div>
    <br>
    本节介绍三种关联容器，单映射QMap、多映射 QMultiMap 和 集合 QSet。
    前面介绍的顺序容器通常存储大量连续序号的元素，而关联容器则存储离散的“不正常序号”的元素。 数组和顺序容器的序号都是从 0
    开始，逐渐递增，而关联容器没有正常的序号， 映射和哈希映射通过重载中括号[]运算符函数，它们的元素序号可以是各种奇葩的数值类型，
    比如用字符串、图片、颜色、日期、字体等数据作为序号，像 map["红色"] = 0xFF0000 就是映射的例子。 集合
    QSet就是数学上的集合，比如求交集∩、求并集∪等。集合的元素没有序号，元素之间也不讲究顺序。 本节共三个小节内容，依次介绍
    QMap、QMultiMap 和 QSet，并各安排一个示例使用这些关联容器。 <br>
    <br>
    <div class="os2">9.3.1 单映射 QMap </div>
    <br>
    QMap 模板类通常将数据按照 key - value（键-值） 配对的形式存储，程序中以 key 作为序号来查询对应的 value，比如&nbsp;
    map["红色"] = 0xFF0000 。QMap 通常将一个 key 映射为一个 value，而 QMultiMap 通常将 一个 key
    映射为多个 value，这就是单映射和多映射的区别。<br>
    QMap 模板类 key 和 value 的类型可以是C++和Qt常用的数据类型，也可以使用自定义类型，<b>但是注意key 和 value
      都必须是可赋值类型！</b><br>
    QMap 使用红黑树存储 key - value 配对数据（ 一对 key - value 后文统称为映射中一个元素，或者红黑树的一个节点），排序时按照
    key 来比较大小，因此对 key 类型有额外要求：<br>
    <b>key 类型必须提供&nbsp; operator&lt;()&nbsp; 比较数值大小。</b><br>
    <br>
    下面我们分类列举QMap模板类的功能函数：<br>
    （1）构造函数<br>
    <div class="code">&nbsp;&nbsp;&nbsp; QMap()&nbsp; //默认构造函数<br>
      &nbsp;&nbsp;&nbsp; QMap(std::initializer_list&lt;std::pair&lt;Key, T&gt;
      &gt; list) //初始化列表构造函数<br>
      &nbsp;&nbsp;&nbsp; QMap(const QMap&lt;Key, T&gt; &amp; other) //复制构造函数<br>
      &nbsp;&nbsp;&nbsp; QMap(QMap&lt;Key, T&gt; &amp;&amp; other)&nbsp;&nbsp;
      //移动构造函数<br>
      &nbsp;&nbsp;&nbsp; QMap(const std::map&lt;Key, T&gt; &amp; other)
      //根据标准库的映射构造 QMap<br>
      &nbsp;&nbsp;&nbsp; ~QMap() //析构函数</div>
    最常用是默认构造函数，注意适用模板类时要带 key 和 value&nbsp; 的类型，必须定义姓名和年龄的映射：<br>
    <div class="code">QMap&lt;QString, int&gt; nameAge;</div>
    QString 作为 key 类型，保存姓名，int 作为 value 类型，保存年龄。<br>
    C++11特性支持初始化列表构造和移动构造，比如：<br>
    <div class="code">&nbsp;&nbsp;&nbsp; QMap&lt;QString, int&gt; nameAge{
      {"Alice", 20},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      {"Bob", 22},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      {"Cell", 19} };<br>
      &nbsp;&nbsp;&nbsp; qDebug()&lt;&lt;nameAge;<br>
      &nbsp;&nbsp;&nbsp; QMap&lt;QString, int&gt; nameAgeOther = std::move(
      nameAge );<br>
      &nbsp;&nbsp;&nbsp; qDebug()&lt;&lt;nameAge;<br>
      &nbsp;&nbsp;&nbsp; qDebug()&lt;&lt;nameAgeOther;</div>
    上面一段代码的输出如下所示：<br>
    <i>QMap(("Alice", 20)("Bob", 22)("Cell", 19))<br>
      QMap()<br>
      QMap(("Alice", 20)("Bob", 22)("Cell", 19))</i><br>
    <br>
    移动构造函数会将 nameAge 内所有元素都转移给 nameAgeOther，因此 nameAge 最后变成空的，而 nameAgeOther
    会包含原本 nameAge 拥有的元素。<br>
    <br>
    std::map 是标准库的映射模板类，包含在 &lt;map&gt; 头文件中，使用方法与 QMap 类似，如果需要从标准库的 map 构造 QMap
    对象，可以参照下面代码编写：<br>
    <div class="code">&nbsp;&nbsp;&nbsp; std::map&lt;QString , int&gt;&nbsp;
      astdMap{ {"Alice", 20},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      {"Bob", 22},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      {"Cell", 19} };<br>
      &nbsp;&nbsp;&nbsp; QMap&lt;QString, int&gt; nameAge( astdMap );</div>
    注意 std::map 和 QMap 的 key、value 类型必须要一致，才能这样构造。<br>
    <br>
    （2）添加函数<br>
    本小节的元素是指一对 key - value ，添加元素后，QMap 内部的红黑树会新加一个节点。<br>
    向 QMap 添加新元素有两种方式，第一种通过两个 insert()&nbsp; 函数：<br>
    <div class="code">iterator&nbsp;&nbsp;&nbsp; insert(const Key &amp; key,
      const T &amp; value) //直接插入一对 key - value<br>
      iterator&nbsp;&nbsp;&nbsp; insert(const_iterator pos, const Key &amp; key,
      const T &amp; value)//在建议的迭代器 pos 位置插入一对 key - value</div>
    第一个 insert() 函数不关心元素插入位置，直接添加到红黑树中；<br>
    第二个 insert() 函数是建议在迭代器 pos 位置插入元素，但是建议的位置不一定有效，红黑树是按照 key
    大小排序的，实际插入的位置是按照排序规则确定的，pos 位置不一定有效，所以一般插入元素推荐用第一个 insert() 函数。<br>
    向 QMap 添加新元素第二种方式，就是运算符重载函数 operator[]() ：<br>
    <div class="code">T &amp; QMap::​operator[](const Key &amp; key)</div>
    两种插入元素方式举例：<br>
    <div class="code">&nbsp;&nbsp;&nbsp; QMap&lt;QString, int&gt; nameAge;<br>
      &nbsp;&nbsp;&nbsp; nameAge.insert( "Alice", 20 );<br>
      &nbsp;&nbsp;&nbsp; nameAge["Bob"] = 22;<br>
      &nbsp;&nbsp;&nbsp; nameAge["Cell"] = 19;</div>
    中括号的方式用起来更像数组，语法也相对简单一些。<br>
    <b><br>
      如果 key - value 配对已经存储在映射对象里面了，那么继续用相同 key 调用 insert() 或 operator[]() ，<br>
      由于单映射的特性，结果就是 key 不变，而 key 对应的 value 会被新的 value 覆盖。</b><br>
    <b> insert() 或 operator[]() 在映射对象里没有 key 时添加新元素，而当已存在 key 时用新value覆盖旧的value。</b><br>
    <br>
    （3）移除和删除函数<br>
    从映射对象卸下一个元素，但不释放空间，使用下面函数：<br>
    <div class="code">T&nbsp;&nbsp;&nbsp; take(const Key &amp; key)</div>
    返回值 T 是 value 类型的数值。如果映射对象里根本没有指定 key，那么返回值是 value 类型默认构造函数生成的对象。<br>
    如果不需要返回值，直接从映射对象删除指定 key 及其 value，使用下面函数：<br>
    <div class="code">int&nbsp;&nbsp;&nbsp; remove(const Key &amp; key)</div>
    返回值是删除元素的个数，如果返回值为 0，说明映射里没有该 value；如果为 1 ，说明正好删除了一对 key - value
    ；如果返回值大于1，说明程序之前使用 insertMulti() 函数为一个 key 添加了多个 value 值（QMap 允许一对多映射，多个
    key-value 元素 的 key 值相同，但一般不建议这样做）。<br>
    如果希望清空所有元素，那么使用如下函数：<br>
    <div class="code">void&nbsp;&nbsp; &nbsp;clear()<br>
    </div>
    <br>
    （4）访问和查询函数<br>
    查询映射对象内是否包含 key 键：<br>
    <div class="code">bool&nbsp;&nbsp; &nbsp;contains(const Key &amp; key) const</div>
    查询映射对象内所有元素数目：<br>
    <div class="code">int&nbsp;&nbsp; &nbsp;count() const<br>
      int&nbsp;&nbsp;&nbsp; size() const</div>
    统计 key 对应的 value 值数量，使用下面函数：<br>
    <div class="code">int&nbsp;&nbsp; &nbsp;count(const Key &amp; key) const</div>
    如果映射对象不存在 key 键，那么返回值为 0，如果存在一对 key-value ，那么返回值为 1；如果程序之前使用 insertMulti()
    函数为一个 key 添加了多个 value，那么返回值是多个 value 值的数量。<br>
    判断映射对象是否全空，没有元素，使用下面两个函数都可以：<br>
    <div class="code">bool&nbsp;&nbsp; &nbsp;empty() const&nbsp; &nbsp; &nbsp;
      //STL风格<br>
      bool&nbsp;&nbsp;&nbsp; isEmpty() const&nbsp;&nbsp; //Qt风格</div>
    <br>
    获取映射中第一个 value 值，使用下面函数：<br>
    <div class="code">T &amp;&nbsp;&nbsp;&nbsp; first()<br>
      const T &amp;&nbsp;&nbsp;&nbsp; first() const</div>
    获取映射中第一个 key 键，使用下面函数：<br>
    <div class="code">const Key &amp;&nbsp;&nbsp;&nbsp; firstKey() const</div>
    获取映射中最后一个 value 值，使用下面函数：<br>
    <div class="code">T &amp;&nbsp;&nbsp;&nbsp; last()<br>
      const T &amp;&nbsp;&nbsp;&nbsp; last() const</div>
    获取映射中最后一个 key 键，使用下面函数：<br>
    <div class="code">const Key &amp;&nbsp;&nbsp;&nbsp; lastKey() const</div>
    <br>
    根据已知 value 值反查归属的 key 键：<br>
    <div class="code">const Key&nbsp;&nbsp;&nbsp; key(const T &amp; value, const
      Key &amp; defaultKey = Key()) const</div>
    反查耗时比较长，需要逐个遍历元素，注意多个 key 对应的 value 可能一样，所以上面函数只返回第一个匹配的 key。如果找不到就返回默认构造的
    Key() 。<br>
    如果要根据 value 反查所有匹配的 key 键列表，使用下面函数：<br>
    <div class="code">QList&lt;Key&gt;&nbsp;&nbsp;&nbsp; keys(const T &amp;
      value) const</div>
    如果需要获取映射所有元素的 key 值列表，使用下面函数：<br>
    <div class="code">QList&lt;Key&gt;&nbsp;&nbsp;&nbsp; keys() const</div>
    注意 insertMulti() 函数可能导致多个 key-value 元素的 key 值一样，keys()
    获取的键值是可能重复的。如果希望获取不重复出现的 key 列表，使用下面函数：<br>
    <div class="code">QList&lt;Key&gt;&nbsp;&nbsp;&nbsp; uniqueKeys() const</div>
    根据 key 查询对应 value ，使用下面函数：<br>
    <div class="code">const T&nbsp;&nbsp;&nbsp; value(const Key &amp; key, const
      T &amp; defaultValue = T()) const</div>
    如果没有找到 key-value 元素，那么返回 T() 值，就是 value 类型默认构造值。<br>
    存在一对多映射的情况下，可以用下面函数获取 key 对应的多个 value 值列表：<br>
    <div class="code">QList&lt;T&gt;&nbsp;&nbsp;&nbsp; values(const Key &amp;
      key) const</div>
    如果要获取映射中所有元素的 value 值列表，使用下面函数：<br>
    <div class="code">QList&lt;T&gt;&nbsp;&nbsp;&nbsp; values() const</div>
    <br>
    （5）交换函数<br>
    将映射对象自身的元素与另一个映射对象中的元素全部互换，使用下面函数：<br>
    <div class="code">void&nbsp;&nbsp; &nbsp;swap(QMap&lt;Key, T&gt; &amp;
      other)</div>
    swap() 函数效率非常高，并且从不失败。<br>
    <br>
    （6）运算符函数<br>
    对于运算符函数，我们以下面两个向量来举例说明：<br>
    <div class="code">&nbsp;&nbsp;&nbsp; QMap&lt;QString, int&gt; m1;<br>
      &nbsp;&nbsp;&nbsp; m1["Alice"] =&nbsp; 20;<br>
      &nbsp;&nbsp;&nbsp; QMap&lt;QString, int&gt; m2;<br>
      &nbsp;&nbsp;&nbsp; m2["Bob"] = 22;<br>
      &nbsp;&nbsp;&nbsp; m2["Cell"] = 19;</div>
    运算符使用示范如下表所示：<br>
    <br>
    <table class="tabel">
      <tbody>
        <tr class="d1">
          <td style="width: 400px;" align="center"><b>运算符函数</b></td>
          <td style="width: 200px;" align="center"><span style="font-weight: bold;">举
              例</span></td>
          <td align="center"><b> 描述</b></td>
        </tr>
        <tr>
          <td>bool operator!=(const QMap&lt;Key, T&gt; &amp; other) const</td>
          <td>&nbsp;m1 != m2;</td>
          <td> 两个映射的元素不一样，不等号判断结果为 true。 </td>
        </tr>
        <tr class="d1">
          <td>bool operator==(const QMap&lt;Key, T&gt; &amp; other) const</td>
          <td>&nbsp;m1 == m2;</td>
          <td> 两个映射的元素不一样，等于号判断结果为 false。</td>
        </tr>
        <tr>
          <td>QMap&lt;Key, T&gt; &amp; operator=(const QMap&lt;Key, T&gt; &amp;
            other)</td>
          <td>&nbsp;m1 = m2;</td>
          <td> 将 m2 所有元素复制给 m1，执行后二者相等。 </td>
        </tr>
        <tr class="d1">
          <td>QMap&lt;Key, T&gt; &amp; operator=(QMap&lt;Key, T&gt; &amp;&amp;
            other)</td>
          <td style="height: 32px;">&nbsp;m1 = std::move(m2);</td>
          <td> 将 m2 中所有元素移动给m1，m2自己清空。 </td>
        </tr>
        <tr>
          <td>T &amp; operator[](const Key &amp; key)</td>
          <td>&nbsp;m2["Cell"]= 18;</td>
          <td style="height: 16px;"> 修改了 "Cell" 对应的value值。 </td>
        </tr>
        <tr class="d1">
          <td>const T operator[](const Key &amp; key) const</td>
          <td style="height: 16px;">&nbsp;qDebug()&lt;&lt; m1["Alice"];</td>
          <td> 打印 "Alice" 对应的常量值。 </td>
        </tr>
      </tbody>
    </table>
    <br>
    （7）迭代器函数<br>
    映射类也定义了 STL 风格和 Qt 命名风格的迭代器：<br>
    <div class="code">class&nbsp;&nbsp; &nbsp;const_iterator&nbsp;&nbsp;
      //STL风格只读迭代器<br>
      class&nbsp;&nbsp; &nbsp;iterator&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp; //STL风格读写迭代器<br>
      typedef&nbsp;&nbsp;&nbsp; ConstIterator&nbsp; //Qt 风格只读迭代器<br>
      typedef&nbsp;&nbsp;&nbsp;
      Iterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Qt风格读写迭代器</div>
    STL 风格迭代器使用示范：<br>
    <div class="code">QMap&lt;QString, int&gt;::const_iterator i =
      map.constBegin();<br>
      while (i != map.constEnd()) {<br>
      &nbsp;&nbsp;&nbsp; cout &lt;&lt; i.key() &lt;&lt; ": " &lt;&lt; i.value()
      &lt;&lt; endl;<br>
      &nbsp;&nbsp;&nbsp; ++i;<br>
      }<br>
    </div>
    获取映射的头部元素、尾部假想元素的迭代器函数列举如下：<br>
    <div class="code">iterator&nbsp;&nbsp; &nbsp;begin()&nbsp;&nbsp;&nbsp;&nbsp;
      //指向头部的读写迭代器<br>
      const_iterator&nbsp;&nbsp; &nbsp;begin() const&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //指向头部的只读迭代器<br>
      const_iterator&nbsp;&nbsp; &nbsp;cbegin() const&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //指向头部的只读迭代器<br>
      const_iterator&nbsp;&nbsp;&nbsp; constBegin() const&nbsp;
      //指向头部的只读迭代器，Qt风格<br>
      iterator&nbsp;&nbsp;&nbsp; end()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      //指向尾部后面假想元素的读写迭代器<br>
      const_iterator&nbsp;&nbsp;&nbsp; end() const&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //指向尾部后面假想元素的只读迭代器<br>
      const_iterator&nbsp;&nbsp; &nbsp;cend() const&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; //指向尾部后面假想元素的只读迭代器<br>
      const_iterator&nbsp;&nbsp;&nbsp; constEnd() const&nbsp; &nbsp;
      //指向尾部后面假想元素的只读迭代器，Qt风格</div>
    注意 *end() 返回的迭代器只能做不等于判断，它指向的东西根本不存在， *end() 仅用于越界判断。<br>
    虽然获取头部、尾部迭代器的函数多，其实功能类似，起了一堆名字是方便兼容 STL 风格函数命名。<br>
    查找指定 key 键对应的迭代器位置，使用下面函数：<br>
    <div class="code">iterator&nbsp;&nbsp;&nbsp; find(const Key &amp;
      key)&nbsp;&nbsp;&nbsp; //根据指定key查找所在位置的读写迭代器<br>
      const_iterator&nbsp;&nbsp;&nbsp; find(const Key &amp; key)
      const&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;
      //根据指定key查找所在位置的只读迭代器，STL风格<br>
      const_iterator&nbsp;&nbsp;&nbsp; constFind(const Key &amp; key)
      const&nbsp;&nbsp;&nbsp; //根据指定key查找所在位置的只读迭代器，Qt风格</div>
    如果存在 key 键的一对多映射，返回最新插入的节点迭代器，相同 key 的多个节点会排在该迭代器之后连续位置；<br>
    如果找不到包含指定 key 的元素，那么查找函数返回 end() 尾部虚假元素迭代器，注意判断几个 *find 函数的返回值。<br>
    根据读写迭代器指定位置，可以删除该位置元素：<br>
    <div class="code">iterator&nbsp;&nbsp;&nbsp; erase(iterator pos)</div>
    删除后返回指向下一元素的迭代器，注意可能是 end() 位置。<br>
    <br>
    QMap 在绝大多数情况下，都是用于一对一映射，但是它也提供了一对多映射的接口函数：<br>
    <div class="code"> //插入指定键值对，如果之前有该键的元素，那么不会替换旧元素，直接增加新的元素，造成一对多映射<br>
      iterator&nbsp;&nbsp;&nbsp; insertMulti(const Key &amp; key, const T &amp;
      value)&nbsp;&nbsp; //插入一对多映射元素<br>
      iterator&nbsp;&nbsp;&nbsp; insertMulti(const_iterator pos, const Key &amp;
      key, const T &amp; value) //在建议的 pos 位置附近插入一对多映射元素</div>
    insertMulti() 会直接向映射添加键值对，并且不会替换旧的相同键值节点，所以会造成多个节点拥有相同的键值，一般不建议这样调用，Qt 专门封装了
    QMultiMap 类用于处理一对多映射。<br>
    <br>
    由于 insertMulti() 会造成一对多映射，红黑树是排序树，同样的 key 键节点是按照排序相邻的，迭代器位置是连续排布的，可以获取一个 key
    对应的多个元素迭代器范围：<br>
    <div class="code">QPair&lt;iterator, iterator&gt;&nbsp;&nbsp;&nbsp;
      equal_range(const Key &amp; key)&nbsp; //返回一对迭代器<br>
      //QPair&lt;iterator, iterator&gt;&nbsp;
      中，第一个迭代器是排在最前面的key键节点位置，第二个是排在最后的key键节点位置<br>
    </div>
    <br>
    根据红黑树的排序特性，QMap 还提供了查找 key 下边界和上边界的迭代器函数：<br>
    <div class="code">iterator&nbsp;&nbsp;&nbsp; lowerBound(const Key &amp;
      key)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //查找 key 下边界的读写迭代器<br>
      const_iterator&nbsp;&nbsp;&nbsp; lowerBound(const Key &amp; key) const
      //查找 key 下边界的只读迭代器<br>
      iterator&nbsp;&nbsp;&nbsp; upperBound(const Key &amp;
      key)&nbsp;&nbsp;&nbsp; //查找 key 上边界的读写迭代器<br>
      const_iterator&nbsp;&nbsp;&nbsp; upperBound(const Key &amp; key) const
      //查找 key 上边界的只读迭代器 </div>
    key 下边界的意思是按照从小到大顺序，找到红黑树中首个满足如下条件的 keyLB 节点：&nbsp; <br>
    keyLB &gt;= key<br>
    如果映射存在 key 节点，那么返回第一个键值等于 key 的节点迭代器；<br>
    如果没有 key 节点，那么返回首个大于 key 的节点迭代器。举例如下：<br>
    <div class="code">QMap&lt;int, QString&gt; map;<br>
      map.insert(1, "one");<br>
      map.insert(5, "five");<br>
      map.insert(10, "ten");<br>
      <br>
      map.lowerBound(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns iterator to
      (1, "one")<br>
      map.lowerBound(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns iterator to
      (1, "one")<br>
      map.lowerBound(2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns iterator to
      (5, "five")<br>
      map.lowerBound(10);&nbsp;&nbsp;&nbsp;&nbsp; // returns iterator to (10,
      "ten")<br>
      map.lowerBound(999);&nbsp;&nbsp;&nbsp; // returns end()</div>
    key 上边界的意思是按照从小到大顺序，找到红黑树中首个满足如下条件的节点 keyUB：<br>
    keyUB &gt; key<br>
    上边界总是返回大于 key 的最邻近节点迭代器。<br>
    举例如下：<br>
    <div class="code">QMap&lt;int, QString&gt; map;<br>
      map.insert(1, "one");<br>
      map.insert(5, "five");<br>
      map.insert(10, "ten");<br>
      <br>
      map.upperBound(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns iterator to
      (1, "one")<br>
      map.upperBound(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns iterator to
      (5, "five")<br>
      map.upperBound(2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns iterator to
      (5, "five")<br>
      map.upperBound(10);&nbsp;&nbsp;&nbsp;&nbsp; // returns end()<br>
      map.upperBound(999);&nbsp;&nbsp;&nbsp; // returns end()</div>
    <br>
    （8）容器类型转换函数<br>
    Qt 提供了映射类，STL 也有自己映射类，两种映射类互相转换的函数如下：<br>
    <div class="code">std::map&lt;Key, T&gt;&nbsp;&nbsp; &nbsp;toStdMap()
      const&nbsp; //转为 STL 映射类<br>
      QMap(const std::map&lt;Key, T&gt; &amp; other) //构造函数，根据 STL 映射构造 QMap 映射<br>
    </div>
    QMap 另外支持两个映射合并，将参数 other 映射的元素全部复制添加给自己，如果两个映射都包含相同的 key，那么合并类似
    insertMulti() 造成一对多映射：<br>
    <div class="code">QMap&lt;Key, T&gt; &amp;&nbsp;&nbsp;&nbsp; unite(const
      QMap&lt;Key, T&gt; &amp; other)</div>
    insertMulti() 和 unite() 会无脑添加新元素，即使新的键值对与旧节点完全一样，比如：<br>
    <div class="code">&nbsp;&nbsp;&nbsp; QMap&lt;QString, int&gt; m1;<br>
      &nbsp;&nbsp;&nbsp; m1["Alice"] =&nbsp; 20;<br>
      &nbsp;&nbsp;&nbsp; QMap&lt;QString, int&gt; m2;<br>
      &nbsp;&nbsp;&nbsp; m2["Alice"] =&nbsp; 20;<br>
      <br>
      &nbsp;&nbsp;&nbsp; m1.unite( m2 );<br>
      &nbsp;&nbsp;&nbsp; m1.insertMulti("Alice",20 );<br>
      <br>
      &nbsp;&nbsp;&nbsp; qDebug()&lt;&lt;m1&lt;&lt;endl&lt;&lt;m2;</div>
    打印结果是 m1 包含三个相同节点：<br>
    <i>QMap(("Alice", 20)("Alice", 20)("Alice", 20)) <br>
      QMap(("Alice", 20))</i><br>
    <br>
    （9）其他内容<br>
    映射类也支持数据串行化，进行数据流输入和输出，但注意前提是 key 和 value 的类型都必须支持串行化：
    <div class="code">QDataStream &amp;&nbsp;&nbsp;
      &nbsp;operator&lt;&lt;(QDataStream &amp; out, const QMap&lt;Key, T&gt;
      &amp; map)&nbsp; //串行化输出<br>
      QDataStream &amp;&nbsp;&nbsp; &nbsp;operator&gt;&gt;(QDataStream &amp; in,
      QMap&lt;Key, T&gt; &amp; map)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; //串行化输入</div>
    <br>
    关于 QMap，这里再提醒两个注意事项：<br>
    <b>① 不能使用 map[key] 这种形式查找映射里是否包含键 key 的元素，因为 ​operator[](const Key &amp;
      key) 函数在找不到 key 元素时，自动调用 value 类默认构造函数为映射添加 key-value 新元素。</b><br>
    应该用 contains(key) 来判断是否包含该 key 元素，或者用&nbsp; map.value( key ) 函数查找值，value()
    函数不会为映射添加新元素，虽然 value() 函数找不到时也会返回 value 类型默认构造的值，但不会改变映射内容。<br>
    <br>
    ② <b>一般不建议使用 insertMulti() 和&nbsp; unite() 进行多重映射添加或映射合并，Qt 单独提供了 QMultiMap
      表示多重映射，在程序中尽量让 QMap 保持一对一映射，避免代码的误解。</b><br>
    <br>
    示例程序：<br>
    <br>
    <br>
    <br>
    <div class="os2">9.3.2 多映射 QMultiMap<span style="color: rgb(0, 0, 0); font-family: Arial, Helvetica; font-size: 13.63636302947998px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 14.545454025268555px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;"><span
          class="Apple-converted-space"> </span></span><span style="color: rgb(0, 0, 0); font-family: Arial, Helvetica; font-size: 13.63636302947998px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 14.545454025268555px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;"></span></div>
    <br>
    <br>
    <br>
    <br>
    <div class="os2">9.3.3 集合 QSet </div>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="width: 40%;">
            <div style="text-align: center;"><a href="ch09-02.htm"><img class="pic"
                  style="width: 32px; height: 32px;" alt="prev" src="images/pics/prev.png"></a></div>
          </td>
          <td style="width: 20%;">
            <div style="text-align: center;"><a href="contents.htm"><img class="pic"
                  style="width: 32px; height: 32px;" alt="contents" src="images/pics/contents.png"></a></div>
          </td>
          <td style="width: 40%;">
            <div style="text-align: center;"><a href="ch09-04.htm"><img class="pic"
                  style="width: 32px; height: 32px;" alt="next" src="images/pics/next.png"></a></div>
          </td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
